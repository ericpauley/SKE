package dnaold

/*
import (
	"fmt"
	"os"
)
import "bufio"
import "strings"
import "sync"
import "time"
import "io/ioutil"
import "encoding/binary"
import "sort"

func check(e error) {
	if e != nil {
		panic(e)
	}
}

type uint64arr []uint64

func (a uint64arr) Len() int           { return len(a) }
func (a uint64arr) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a uint64arr) Less(i, j int) bool { return a[i] < a[j] }

//Sector describes a file where kmers are stored
type Sector struct {
	f       *os.File
	towrite chan uint64
	size    int
}

func sector(s *Sector, join *sync.WaitGroup) {
	b := bufio.NewWriterSize(s.f, 1024*1024)
	for v := range s.towrite {
		s.size++
		binary.Write(b, binary.LittleEndian, v)
	}
	b.Flush()
	join.Done()
}

func sloader(sectors []Sector, tosort chan *uint64arr) {
	for i, s := range sectors {
		println("Loading sector", i, s.size)
		b := bufio.NewReaderSize(s.f, 1024*1024)
		slots := make(uint64arr, s.size)
		var err error
		for i := 0; i < s.size; i++ {
			slots[i], err = binary.ReadUvarint(b)
			check(err)
		}
		tosort <- &slots
		os.Remove(s.f.Name())
	}
	close(tosort)
}

func ssorter(tosort chan *uint64arr, towrite chan *uint64arr) {
	for slots := range tosort {
		println("Sorting sector")
		sort.Sort(slots)
		towrite <- slots
	}
	close(towrite)
}

func parser(ch chan string, join *sync.WaitGroup, sectors *[]Sector) {
	defer join.Done()
	for s := range ch {
		var kmer uint64
		for len, c := range s {
			kmer = kmer >> 2
			switch {
			case c == 'A' || c == 'a':
			case c == 'C' || c == 'c':
				kmer |= 1 << 62
			case c == 'G' || c == 'g':
				kmer |= 2 << 62
			case c == 'T' || c == 't':
				kmer |= 3 << 62
			}
			if len >= 7 {
				if len > 30 {
					len = 30
				}
				data := kmer | (uint64(01) << uint(62-(len+1)*2))
				(*sectors)[data>>58].towrite <- data
			}
		}
	}
}

func saver(towrite chan *uint64arr) {
	tosave := make([]*os.File, 31)
	for slots := range towrite {
		for _, kmer := range *slots {
			len := 31
			for kmer&1 == 1 {
				kmer >>= 2
				len--
			}
			kmer >>= 2
		}
	}
}

func main() {
	start := time.Now()
	f, err := os.Open("ecoli.fasta")
	check(err)
	fi, err := f.Stat()
	size := fi.Size()
	scanner := bufio.NewScanner(bufio.NewReader(f))

	var current string
	index := 0

	var sectors = make([]Sector, 64)
	var sjoin sync.WaitGroup
	sjoin.Add(64)
	for i := range sectors {
		sectors[i].f, err = ioutil.TempFile("", "kmer")
		sectors[i].towrite = make(chan uint64, 1000)
		check(err)
		go sector(&sectors[i], &sjoin)
		defer os.Remove(sectors[i].f.Name())
	}

	c := make(chan string, 1000)
	var pjoin sync.WaitGroup
	pjoin.Add(10)
	for i := 0; i < 10; i++ {
		go parser(c, &pjoin, &sectors)
	}

	for scanner.Scan() {
		if strings.HasPrefix(scanner.Text(), ">") {
			index++
			if index%100000 == 0 {
				pos, err := f.Seek(0, 1)
				check(err)
				fmt.Println(scanner.Text(), len(current), pos*100/size, time.Since(start), time.Since(start).Nanoseconds()/1000000*size/pos)
			}
			c <- current
			current = ""
		} else {
			current += scanner.Text()
		}
	}
	close(c)
	pjoin.Wait()
	for i := range sectors {
		close(sectors[i].towrite)
	}
	sjoin.Wait()
	fmt.Println("Sectoring took", time.Since(start))

	tosort := make(chan *uint64arr, 1)
	towrite := make(chan *uint64arr, 1)

	go sloader(sectors, tosort)
	go ssorter(tosort, towrite)
}
*/
